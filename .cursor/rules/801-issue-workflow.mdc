---
description: AUTOMATE issue workflow with strict documentation-first approach when handling issue lifecycle
globs: **/*
alwaysApply: true
---

# Issue Workflow

## Context
- When starting work on an issue ("issue start #xxx")
- When completing an issue ("issue done #xxx")
- When closing an issue ("close issue #xxx")
- When documentation needs to be maintained

## Requirements
- Follow strict order for issue lifecycle actions
- Create and maintain documentation before code changes
- Use standardized templates for consistency
- Enforce documentation-first approach
- Create temporary markdown files for formatted documentation
- Upload formatted documentation from temporary files
- Clean up temporary files after successful upload

## Command Actions
### "issue start #xxx"
1. Create feature branch
2. Update issue status
3. Add implementation plan

### "issue done #xxx" (STRICT ORDER)
1. Create implementation summary FIRST:
   ```bash
   cat > .temp_issue_xxx_summary.md << 'EOL'
   # Implementation Summary Template
   [Paste formatted markdown content here]
   EOL
   
   gh issue comment xxx "$(cat .temp_issue_xxx_summary.md)"
   rm .temp_issue_xxx_summary.md
   ```
2. Update issue documentation BEFORE other actions
3. ONLY THEN:
   - Commit final changes
   - Push changes
   - Create merge request
   - Link merge request with issue

### "issue close #xxx"
1. Create closing summary:
   ```bash
   cat > .temp_issue_xxx_closing.md << 'EOL'
   # Closing Summary Template
   [Paste formatted markdown content here]
   EOL
   
   gh issue comment xxx "$(cat .temp_issue_xxx_closing.md)"
   rm .temp_issue_xxx_closing.md
   ```
2. Verify documentation completeness
3. Update issue status

## Implementation Template
```markdown
# Implementation Summary for #XXX üöÄ

## üìù Overview
[Brief description of the implemented feature/fix]

## üõ† Implementation Details
### Components/Features Added
- List of main components
- Key features implemented

### Core Features
- ‚ú® Feature 1
- üíæ Feature 2
- üß™ Feature 3

## ü§î Key Decisions
1. **Architecture Choice**
   - Chosen approach
   - Rationale

2. **Technical Decisions**
   - Technical choices
   - Trade-offs considered

## üîß Technical Implementation
### Technologies Used
- List of technologies
- Key libraries/frameworks

### Architecture/Flow
1. Component interactions
2. Data flow
3. Key processes

## üìà Future Improvements
- [ ] Potential enhancement 1
- [ ] Potential enhancement 2

## üéØ Completion Status
- ‚úÖ Feature 1
- ‚úÖ Feature 2
- ‚úÖ Documentation
```

## Examples
<example>
User: "issue done #123"
AI:
1. Creates temporary markdown file with implementation summary:
   ```bash
   cat > .temp_issue_123_summary.md << 'EOL'
   # Implementation Summary for #123 üöÄ
   ## üìù Overview
   Added user authentication system
   ## üõ† Implementation Details
   - Implemented JWT-based auth
   - Added login/register UI
   ## ü§î Key Decisions
   - Used JWT for stateless auth
   - Implemented refresh token rotation
   EOL
   ```

2. Uploads formatted content to issue:
   ```bash
   gh issue comment 123 "$(cat .temp_issue_123_summary.md)"
   rm .temp_issue_123_summary.md
   ```

3. ONLY THEN proceeds with code changes and MR
</example>

<example type="invalid">
‚ùå User: "issue done #123"
AI: Creates merge request before documentation

‚ùå User: "issue done #123"
AI: Pushes code changes without implementation summary

‚ùå User: "issue done #123"
AI: Closes issue without proper documentation

‚ùå User: "issue done #123"
AI: Directly uploads unformatted text to issue

‚ùå User: "issue done #123"
AI: Forgets to clean up temporary files
</example>

## Critical Rules
  - MUST create documentation BEFORE any code changes
  - MUST follow strict action order (docs -> code -> MR)
  - NEVER skip documentation steps
  - ALWAYS use provided templates
  - VERIFY documentation completeness before closing
  - MAINTAIN clear structure and use emojis for readability
  - MUST use temporary files for formatted text upload
  - MUST clean up temporary files after successful upload